# js 中对于异步的处理有那么几种方式：

1. 函数回调
  优点：理解起来简单
  缺点：回调地狱

2. Promise

  promise 的使用

  ```js
  let p = new Promise((resolve, reject) => {
    /** 成功 */
    resolve('success')
    /** 失败, 两者只会触发一个 */
    reject('fail')
  })

  处理:
  p.then(
    (next) => {},
    (err) => {}
  )

  p.catch(
    err => {}
  )
  ```

  链式调用:

  ```js
    new Promise((resolve, reject) => {
      resolve('success')
    }).then(
      (next) => {
        return 'success again'
      }
    ).then(
      (val) => {
        console.log('val', val)
      }
    )
  ```
  如上，我们可以调用多个 `then`， 但第二个 then 中的值是上一个 return 的值，我们并不能在里面重复地 resolve 或者 reject, 因此这并不是严格意义上的链式调用

  ```js
    new Promise((resolve, reject) => {
      resolve('success')
    }).then(
      (next) => {
        return new Promise((resolve, reject) => {
          resolve('success again')
        })
      }
    ).then(
      (next) => {
        console.log('val', next)
      }
    )
  ```

  `Promise` 静态方法有：
    Promise.resolve()
    Promise.reject()
    Promise.all() 等待所有的 promise 为 resolve 时返回存放它们结果的数组，如果任意给定的Promise 为 reject, 那么它会变成错误结果，其他结果都会被忽略
    Promise.allSettled 等待所哟逇 promise 的结果，不论是 resolve 还是reject， 返回结果的数组
    Promise.race 等待第一个promise 被解决，其 resolve 或者 reject 便是结果



3. async / await 
  Es6 特性，

4. Rxjs